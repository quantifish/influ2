---
title: "influ2"
author: "Darcy Webber"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{influ2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

The `influ2` package is based on the original `influ` package which was developed to generate influence statistics and associated plots. The `influ` package has functions that use outputs from the `glm` function. The `influ2` package was developed to use outputs from `brms` and relies heavily on the R packages `ggplot2` and `dplyr`. This vignette showcases the `influ2` package.


# Functions for exploring data

In this vignette I use the `iris` data set to generate a fake catch per unit effort (CPUE) data set. This data set has a response variable labelled `CPUE` and has the dependent variables `Year` (from 1990 to 2014), `Species` (3 species), `Area` (3 areas) and `Duration`. No step-wise variable selection or model selection is done in this vignette.

The main function for exploring data in `influ2` is `plot_bubble` which presents the number of records by two user defined groups within a data set. The bubble size in `plot_bubble` represents the number of records across the entire data set, and bubbles can either be a single colour or coloured by a third variable in the data set.

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
library(reshape2)
library(tidyverse)
library(brms)
library(influ2)
library(bayesplot)

# options(mc.cores = parallel::detectCores())

# Get some data to use
data(iris)
glimpse(iris)

iris2 <- iris %>% 
  mutate(CPUE = Petal.Length, 
         Year = factor(Sepal.Width * 10 + 1970), 
         Area = factor(round(Petal.Width)), 
         Duration = Sepal.Length,
         Duration2 = cut(Sepal.Length, 20)) %>%
  select(CPUE, Year, Species, Area, Duration, Duration2)
glimpse(iris2)
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE, fig.cap = "Distribution of data by year and duration."}
plot_bubble(df = iris2, group = c("Year", "Duration2"), fill = "green")
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE, fig.cap = "Distribution of data by year and species."}
plot_bubble(df = iris2, group = c("Year", "Species"), fill = "Area")
```

# The origninal influ versus influ2

First I fit three different models of increasing complexity in `brms`. The third model includes the explanatory variables `Year`, `Species` and `Area`. I then fit another four models which include `Year` and different forms of the variable `Duration`. The different forms include a linear predictor, a third-order polynomial, a spline, and a random-effect. A few different distributions are used to mix things up as well including lognormal, Gaussian, Gamma, and Weibull.

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
# Fit a series of models using brms
do_mcmc <- FALSE
if (do_mcmc) {
  # A set of lognormal models
  fit0 <- brm(CPUE ~ Year, data = iris2, family = lognormal(), refresh = 0)
  fit1 <- brm(CPUE ~ Year + Duration, data = iris2, family = lognormal(), refresh = 0)
  fit2 <- brm(CPUE ~ Year + Duration + Species, data = iris2, family = lognormal(), refresh = 0)
  
  # Gaussian, Gamma, and Weibull
  fit3 <- brm(CPUE ~ Year + poly(Duration, 3), data = iris2, refresh = 0)
  fit4 <- brm(CPUE ~ Year + s(Duration), data = iris2, family = Gamma(link = "log"), refresh = 0)
  fit5 <- brm(CPUE ~ Year + (1|Duration2), data = iris2, family = weibull, refresh = 0)
  fit6 <- brm(CPUE ~ Year + Duration2, data = iris2, family = weibull, refresh = 0)
  
  save(fit0, fit1, fit2, fit3, fit4, fit5, file = "mcmc.rda")
} else{
  load("mcmc.rda")
}

# Fit a model using glm and generate influence statistics using the original influ package
fit_glm <- glm(log(CPUE) ~ Year + Duration + Species, data = iris2)
source("../tests/testthat/influ.R")
myInfl <- Influence$new(fit_glm)
myInfl$calc()
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE, fig.cap = "The original CDI plot from the influ package."}
myInfl$cdiPlot(term = "Species")
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE, fig.cap = "A Bayesian version of original CDI plot."}
# Generate a CDI plot for a factor - this version aims to look the same as the old version
plot_bayesian_cdi2(fit = fit2, group = c("Year", "Species"), xlab = "Species")
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE, fig.cap = "The new Bayesian CDI plot from the influ2 package."}
# Generate a CDI plot for a factor
plot_bayesian_cdi(fit = fit2, group = c("Year", "Species"), xlab = "Species")
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE, fig.cap = "The original step-plot from the influ package."}
myInfl$stepPlot()
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE, fig.cap = "The new Bayesian step-plot from the influ2 package. Note that the new step-plot requires that all models/steps be run in brms before the function can be used."}
fits <- list(fit0, fit1, fit2)
plot_step(fits = fits, year = "Year", probs = c(0.25, 0.75), show_probs = TRUE)
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
plot_index(fit2, year = "Year")
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
myInfl$stanPlot()
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
plot_influ(fit2, year = "Year")
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
myInfl$influPlot()
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
i1 <- myInfl$influences %>%
  pivot_longer(cols = -level, names_to = "variable")
i2 <- get_influ(fit = fit2, group = c("Year", "Species")) %>%
  group_by(Year) %>%
  summarise(delta = mean(delta)) %>%
  mutate(variable = "Species")
i3 <- get_influ(fit = fit2, group = c("Year", "Duration")) %>%
  group_by(Year) %>%
  summarise(delta = mean(delta)) %>%
  mutate(variable = "Duration")

ggplot(data = rbind(i2, i3)) +
  geom_point(data = i1, aes(x = level, y = exp(value))) +
  geom_line(aes(x = Year, y = exp(delta), colour = variable, group = variable)) +
  facet_wrap(variable ~ ., ncol = 1, scales = "free_y") +
  labs(x = NULL, y = "Influence") +
  theme_bw() +
  theme(legend.position = "none", axis.text.x = element_text(angle = 45, hjust = 1))
```


# Functions for exploring models

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
# Here I evaluate model fit using loo and waic. 
# Other options include kfold, loo_subsample, bayes_R2, loo_R2 and marglik
criterion <- c("loo", "waic", "bayes_R2")
fit0 <- add_criterion(fit0, criterion = criterion)
fit1 <- add_criterion(fit1, criterion = criterion)
fit2 <- add_criterion(fit2, criterion = criterion)
fit3 <- add_criterion(fit3, criterion = criterion)
fit4 <- add_criterion(fit4, criterion = criterion)
fit5 <- add_criterion(fit5, criterion = criterion)

fit0$criteria$loo
fit0$criteria$waic
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
loo_compare(fit0, fit1, fit2, fit3, fit4, fit5, criterion = "loo") %>%
  knitr::kable(digits = 1)
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
loo_compare(fit0, fit1, fit2, fit3, fit4, fit5, criterion = "waic") %>%
  knitr::kable(digits = 1)
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
fits <- list(fit0, fit1, fit2, fit3, fit4, fit5)
r2 <- matrix(NA, nrow = nrow(fits[[1]]$criteria$bayes_R2), ncol = length(fits))
for (i in 1:length(fits)) r2[,i] <- fits[[i]]$criteria$bayes_R2
colMeans(r2)
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
# Generate a CDI plot for a linear variable
plot_bayesian_cdi(fit = fit1, group = c("Year", "Duration"), xlab = "Duration")
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
# Generate a CDI plot for a polynomial variable
plot_bayesian_cdi(fit = fit3, group = c("Year", "Duration"), xlab = "Duration")
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
# Generate a CDI plot for a spline
plot_bayesian_cdi(fit = fit4, group = c("Year", "Duration"), xlab = "Duration")
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
# Generate a CDI plot for a random-effect
plot_bayesian_cdi(fit = fit5, group = c("Year", "Duration2"), xlab = "Duration")

# Generate a CDI plot for a fixed-effect
plot_bayesian_cdi(fit = fit6, group = c("Year", "Duration2"), xlab = "Duration")
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
fits <- list(fit1, fit3, fit4, fit5)
plot_compare(fits = fits, labels = c("linear", "poly", "spline", "random-effect"), year = "Year")
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
plot_index(fit = fit4, year = "Year")
```

# Diagnostics

The `influ2` package is based on the original `influ` package which was developed to generate influence plots. The `influ` package has functions that use outputs from the `glm` function. The `influ2` package was developed to use outputs from `brms` and relies heavily on the R packages `ggplot2` and `dplyr`. This vignette showcases the `influ2` package with a focus on model diagnostics including posterior predictive distributions, residuals, and quantile-quantile plots.

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
yrep <- posterior_predict(fit4, draws = 100)

ppc_dens_overlay(y = iris2$CPUE, yrep = yrep) + 
  labs(x = "CPUE", y = "Density") +
  theme_bw()

ppc_ecdf_overlay(y = iris2$CPUE, yrep = yrep) +
  coord_cartesian(xlim = c(0, 10)) +
  theme_bw()
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE, fig.cap = "Residuals and a loess smoother."}
plot_predicted_residuals(fit = fit4, trend = "loess")
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE, fig.cap = "Residuals and a loess smoother."}
plot_predicted_residuals(fit = fit4, trend = "lm") +
  facet_wrap(Year ~ .)

# A new style of residual plot
  fit = fit4
  # Extract predicted values
  pred <- fitted(fit) %>% data.frame()
  names(pred) <- paste0("pred.", names(pred))
  
  # Extract residuals
  resid <- residuals(fit) %>% data.frame()
  names(resid) <- paste0("resid.", names(resid))
  
  df <- cbind(resid, pred, iris2)
  head(df)
  
  p <- ggplot(data = df, aes(x = Year, y = .data$resid.Estimate)) +
    geom_pointrange(aes(ymin = .data$resid.Q2.5, ymax = .data$resid.Q97.5), alpha = 0.75) +
    facet_wrap(Area ~ Species) +
    # geom_hline(yintercept = 0, linetype = "dashed") +
    # geom_errorbarh(aes(xmax = .data$pred.Q2.5, xmin = .data$pred.Q97.5, height = 0), alpha = 0.75) +
    # labs(x = "Predicted values", y = "Residuals") +
    theme_bw()
  p
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE, fig.cap = "Implied residuals."}
plot_implied_residuals(fit = fit2, data = iris2, year = "Year")
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
plot_qq(fit4)
```

# Functions for generating outputs for stock assessment

Finally, in order to fit to the data in a stock assessment model then indices can be produced using the `get_index` function.

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
get_index(fit = fit2, year = "Year") %>%
  select(Year, Estimate, Est.Error, Qlower, Q50, Qupper) %>%
  knitr::kable(digits = 3)
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
cpue1 <- get_index(fit = fit2, year = "Year") %>% mutate(Type = "GLM")
cpue2 <- cpue1 %>% mutate(Type = "Simulated")
for (ii in 1:nrow(cpue1)) {
  # sdd <- cpue1$Est.Error[ii] # this is wrong
  sdd <- log(1 + cpue1$Est.Error[ii] / cpue1$Estimate[ii])
  r1 <- rlnorm(n = 5000, log(cpue1$Q50[ii]), sdd)
  cpue2$Q50[ii] <- median(r1)
  cpue2$Qlower[ii] <- quantile(r1, probs = 0.025)
  cpue2$Qupper[ii] <- quantile(r1, probs = 0.975)
}

ggplot(data = rbind(cpue1, cpue2), aes(x = Year, y = Q50, colour = Type)) +
  geom_pointrange(aes(ymin = Qlower, ymax = Qupper), position = position_dodge(width = 0.5)) +
  labs(x = NULL, y = "CPUE") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
