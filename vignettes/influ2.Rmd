---
title: "influ2"
author: "Darcy Webber"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{influ2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

The `influ2` package is based on the original `influ` package which was developed to generate influence statistics and associated plots. The `influ` package has functions that use outputs from the `glm` function. The `influ2` package was developed to use outputs from `brms` and relies heavily on the R packages `ggplot2` and `dplyr`. This vignette showcases the `influ2` package.


# Functions for exploring data

In this vignette I use the `iris` data set to generate a fake catch per unit effort (CPUE) data set. This data set has a response variable labelled `CPUE` and has the dependent variables `Year` (from 1990 to 2014), `Species` (3 species), `Area` (3 areas) and `Duration`. No step-wise variable selection or model selection is done in this vignette.

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
library(reshape2)
library(readr)
library(brms)
library(influ2)
library(bayesplot)

# options(mc.cores = parallel::detectCores())

# Get some data to use
data(iris)
glimpse(iris)

iris2 <- iris %>% 
  mutate(CPUE = Petal.Length, 
         Year = factor(Sepal.Width * 10 + 1970), 
         Area = factor(round(Petal.Width)), 
         Duration = Sepal.Length,
         Duration2 = cut(Sepal.Length, 20)) %>%
  select(CPUE, Year, Species, Area, Duration, Duration2)
glimpse(iris2)
```

The main function for exploring data in `influ2` is `plot_bubble` which presents the number of records by two user defined groups within a data set. The bubble size in `plot_bubble` represents the number of records across the entire data set, and bubbles can either be a single colour or coloured by a third variable in the data set.

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
plot_bubble(df = iris2, group = c("Year", "Duration2"), fill = "green")
plot_bubble(df = iris2, group = c("Year", "Species"), fill = "Area")
```


# Functions for exploring models

First I fit three different models of increasing complexity in `brms`. The third model includes the explanatory variables `Year`, `Species` and `Area`. I then fit another four models which include `Year` and different forms of the variable `Duration`. The different forms include a linear predictor, a third-order polynomial, a spline, and a random-effect.

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
# Fit a series of models using brms
do_mcmc <- TRUE
if (do_mcmc) {
  # A set of lognormal models
  fit0 <- brm(CPUE ~ Year, data = iris2, family = lognormal(), refresh = 0)
  fit1 <- brm(CPUE ~ Year + Duration, data = iris2, family = lognormal(), refresh = 0)
  fit2 <- brm(CPUE ~ Year + Duration + Species, data = iris2, family = lognormal(), refresh = 0)
  
  # Gaussian, Gamma, and Weibull
  fit3 <- brm(CPUE ~ Year + poly(Duration, 3), data = iris2, refresh = 0)
  fit4 <- brm(CPUE ~ Year + s(Duration), data = iris2, family = Gamma(link = "log"), refresh = 0)
  fit5 <- brm(CPUE ~ Year + (1|Duration2), data = iris2, family = weibull, refresh = 0)
  
  save(fit0, fit1, fit2, fit3, fit4, fit5, file = "mcmc.rda")
} else{
  load("mcmc.rda")
}
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
# Generate a step plot
fits <- list(fit0, fit1, fit2)
plot_step(fits = fits, year = "Year", probs = c(0.25, 0.75), show_probs = TRUE)
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
# Here I evaluate model fit using loo and waic. 
# Other options include kfold, loo_subsample, bayes_R2, loo_R2 and marglik
fit0 <- add_criterion(fit0, criterion = c("loo", "waic"))
fit1 <- add_criterion(fit1, criterion = c("loo", "waic"))
fit2 <- add_criterion(fit2, criterion = c("loo", "waic"))

fit0$criteria$loo
fit0$criteria$waic
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
loo_compare(fit0, fit1, fit2, criterion = "loo") %>%
  knitr::kable(digits = 1)
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
loo_compare(fit0, fit1, fit2, criterion = "waic") %>%
  knitr::kable(digits = 1)
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
plot_influ(fit = fit2, year = "Year")
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
# Generate a CDI plot for a factor
plot_bayesian_cdi(fit = fit2, group = c("Year", "Species"), xlab = "Species")
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
# Generate a CDI plot for a linear variable
plot_bayesian_cdi(fit = fit1, group = c("Year", "Duration"), xlab = "Duration")

# Generate a CDI plot for a polynomial variable
plot_bayesian_cdi(fit = fit3, group = c("Year", "Duration"), xlab = "Duration")

# Generate a CDI plot for a spline
plot_bayesian_cdi(fit = fit4, group = c("Year", "Duration"), xlab = "Duration")

# Generate a CDI plot for a random-effect
plot_bayesian_cdi(fit = fit5, group = c("Year", "Duration2"), xlab = "Duration")
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
fits <- list(fit1, fit3, fit4, fit5)
plot_compare(fits = fits, labels = c("linear", "poly", "spline", "random-effect"), year = "Year")
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
plot_index(fit = fit4, year = "Year")
```

# Diagnostics

The `influ2` package is based on the original `influ` package which was developed to generate influence plots. The `influ` package has functions that use outputs from the `glm` function. The `influ2` package was developed to use outputs from `brms` and relies heavily on the R packages `ggplot2` and `dplyr`. This vignette showcases the `influ2` package with a focus on model diagnostics including posterior predictive distributions, residuals, and quantile-quantile plots.

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
yrep <- posterior_predict(fit4, draws = 500)
ppc_dens_overlay(y = iris2$CPUE, yrep = yrep[1:100,]) + 
  theme_bw() +
  labs(x = "CPUE", y = "Density")

plot_predicted_residuals(fit4)

plot_qq(fit4)
```

# Functions for generating outputs for stock assessment

Finally, in order to fit to the data in a stock assessment model then indices can be produced using the `get_index` function.

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
get_index(fit = fit2, year = "Year") %>%
  select(Year, Estimate, Est.Error, Qlower, Q50, Qupper) %>%
  knitr::kable(digits = 3)
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
cpue1 <- get_index(fit = fit2, year = "Year") %>% mutate(Type = "GLM")
cpue2 <- cpue1 %>% mutate(Type = "Simulated")
for (ii in 1:nrow(cpue1)) {
  # sdd <- cpue1$Est.Error[ii] # wrong
  sdd <- log(1 + cpue1$Est.Error[ii] / cpue1$Estimate[ii])
  r1 <- rlnorm(n = 5000, log(cpue1$Q50[ii]), sdd)
  cpue2$Q50[ii] <- median(r1)
  cpue2$Qlower[ii] <- quantile(r1, probs = 0.025)
  cpue2$Qupper[ii] <- quantile(r1, probs = 0.975)
}
ggplot(data = rbind(cpue1, cpue2), aes(x = Year)) +
  geom_pointrange(aes(y = Q50, ymin = Qlower, ymax = Qupper, colour = Type), position = position_dodge(width = 0.5)) +
  theme_bw()
```
