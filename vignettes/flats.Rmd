---
title: "influ2"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{influ2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The `influ2` package is based on the original `influ` package which was developed to generate influence plots. The `influ` package has functions that use outputs from the `glm` function. The `influ2` package was developed to use outputs from `brms` and relies heavily on the R packages `ggplot2` and `dplyr`. This vignette showcases the `influ2` package and compares outputs with the original `influ` package.

In this vignette I use the `iris` data set to generate a fake catch per unit effort (CPUE) data set. This data set has a response variable labelled `CPUE` and has the dependent variables `Year` (from 1990 to 2014), `Species` (3 species), `Area` (3 areas) and `Area2` (22 areas). No step-wise variable selection or model selection is done in this vignette.

I fit three different models of increasing complexity. A basic `glm` of the third model, which includes the explanatory variables `Year`, `Species` and `Area`, is also done for comparison. Influence plots from the original `influ` package are generated and compared with plots from the new `influ2` package.

Note that the bubble size in `influ` represents the proportion of records for each species each year (i.e. rows sum to 1), while in `influ2` the bubble size represents the number of records across the entire data set.

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
library(readr)
library(brms)
library(influ2)
library(bayesplot)

# options(mc.cores = parallel::detectCores())

# Get some data to use
flats <- read_csv("flats.csv") %>%
  rename(vessel = vess, duration = towDur, catch = yfswt, latitude = lat, longitude = long, area = adfg) %>%
  filter(!is.na(latitude), !is.na(longitude), catch > (fhswt + nrswt)) %>%
  mutate(vessel = as.numeric(as.factor(vessel)), cpue = catch / duration) %>%
  select(cpue, catch, duration, vessel, year, week, latitude, longitude, area)
core_area <- flats %>%
  group_by(area) %>%
  summarise(catch = sum(catch)) %>%
  arrange(-catch)
write_csv(flats %>% filter(area %in% core_area$area[1:30]), "flats2.csv")
ct <- cols(col_double(), col_double(), col_double(), col_character(), col_character(), col_character(), col_double(), col_double(), col_character())
flats <- read_csv("flats2.csv", col_types = ct)
glimpse(flats)
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
# Fit a series of models using glm
fit_glm0 <- glm(log(cpue) ~ year, data = flats)
fit_glm1 <- glm(log(cpue) ~ year + week, data = flats)
fit_glm2 <- glm(log(cpue) ~ year + week + vessel, data = flats)

# Fit a series of models using brms
fit0 <- brm(cpue ~ year, data = flats, family = lognormal(), refresh = 0)
fit1 <- brm(cpue ~ year + area, data = flats, family = lognormal(), refresh = 0)
fit2 <- brm(cpue ~ year + area + vessel, data = flats, family = lognormal(), refresh = 0)

# Generate a CDI plot using the influ2 package
plot_bayesian_cdi(fit = fit2, group = c("year", "vessel"), xlab = "Vessel")
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
# Generate a step plot
fits <- list(fit0, fit1, fit2)
plot_step(fits, year = "year", probs = c(0.25, 0.75), show_probs = TRUE)

plot_index(fit2, year = "year")
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
plot_influ(fit2, year = "year")
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
# Here I evaluate model fit using loo and waic. 
# Other options include kfold, loo_subsample, bayes_R2, loo_R2 and marglik
fit0 <- add_criterion(fit0, criterion = c("loo", "waic"))
fit1 <- add_criterion(fit1, criterion = c("loo", "waic"))
fit2 <- add_criterion(fit2, criterion = c("loo", "waic"))

loo_compare(fit0, fit1, fit2, criterion = "loo")
loo_compare(fit0, fit1, fit2, criterion = "waic")
fit0$criteria$loo
fit1$criteria$waic

yrep <- posterior_predict(fit2, draws = 500)
ppc_dens_overlay(y = flats$cpue, yrep = yrep[1:100,]) + 
  theme_bw() +
  coord_cartesian(xlim = c(0, 20)) +
  labs(x = "CPUE", y = "Density")

plot_predicted_residuals(fit2)
```
