---
title: "inlfu versus influ2"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{influ_vs_influ2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The `influ2` package is based on the original `influ` package which was developed to generate influence plots. The `influ` package has functions that use outputs from the `glm` function. The `influ2` package was developed to use outputs from `brms` and relies heavily on the R packages `ggplot2` and `dplyr`. This vignette showcases the `influ2` package and compares outputs with the original `influ` package.

In this vignette I use the `iris` data set to generate a fake catch per unit effort (CPUE) data set. This data set has a response variable labelled `CPUE` and has the dependent variables `Year` (from 1990 to 2014), `Species` (3 species), `Area` (3 areas) and `Area2` (22 areas). No step-wise variable selection or model selection is done in this vignette.

I fit three different models of increasing complexity. A basic `glm` of the third model, which includes the explanatory variables `Year`, `Species` and `Area`, is also done for comparison. Influence plots from the original `influ` package are generated and compared with plots from the new `influ2` package.

Note that the bubble size in `influ` represents the proportion of records for each species each year (i.e. rows sum to 1), while in `influ2` the bubble size represents the number of records across the entire data set.

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
library(reshape2)
library(readr)
library(brms)
library(influ2)
library(bayesplot)
source("../tests/testthat/influ.R")

# options(mc.cores = parallel::detectCores())

# Get some data to use
data(iris)
glimpse(iris)

iris2 <- iris %>% 
  mutate(CPUE = Petal.Length, 
         Year = factor(Sepal.Width * 10 + 1970), 
         Area = factor(round(Petal.Width)), 
         Duration = Sepal.Length,
         Duration2 = cut(Sepal.Length, 20)) %>%
  select(CPUE, Year, Species, Area, Duration, Duration2)
glimpse(iris2)
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
# Fit a brms model
fit0 <- brm(CPUE ~ Year, data = iris2, family = lognormal(), refresh = 0)
fit1 <- brm(CPUE ~ Year + Species, data = iris2, family = lognormal(), refresh = 0)
fit2 <- brm(CPUE ~ Year + Species + Area, data = iris2, family = lognormal(), refresh = 0)

# Also fit a model using glm and generate influence statistics using the original influ package
fit_glm <- glm(log(CPUE) ~ Year + Species + Area, data = iris2)
myInfl <- Influence$new(fit_glm)
myInfl$calc()
myInfl$cdiPlot(term = "Species")
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
# Generate a CDI plot for a factor
plot_bayesian_cdi2(fit = fit2, group = c("Year", "Species"), xlab = "Species")
plot_bayesian_cdi(fit = fit2, group = c("Year", "Species"), xlab = "Species")
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
# Generate a step plot
fits <- list(fit0, fit1, fit2)
plot_step(fits = fits, year = "Year", probs = c(0.25, 0.75), show_probs = TRUE)
myInfl$stepPlot()
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
plot_index(fit2, year = "Year")
myInfl$stanPlot()
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
plot_influ(fit2, year = "Year")
myInfl$influPlot()

i1 <- myInfl$influences

i2 <- get_influ(fit = fit2, group = c("Year", "Species")) %>%
  group_by(Year) %>%
  summarise(delta = mean(delta))

plot(i1$Species, type = "b")
lines(i2$delta, col = 2)

i2 <- get_influ(fit = fit2, group = c("Year", "Area")) %>%
  group_by(Year) %>%
  summarise(delta = mean(delta))

plot(i1$Area, type = "b")
lines(i2$delta, col = 2)
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
fit <- fit2
yrs <- sort(unique(fit$data$Year))
ce <- conditional_effects(x = fit, effects = "Year", method = "pp_expect")
newdata <- data.frame(id = 1:length(yrs), Year = yrs, Species = NA, Area = NA)
pp <- pp_expect(fit, newdata = newdata) %>%
  melt(varnames = c("iteration", "id")) %>%
  left_join(newdata, by = "id")

ggplot(data = pp, aes(x = Year, y = value)) +
  geom_violin() +
  geom_pointrange(data = ce[[1]], aes(x = Year, y = estimate__, ymin = lower__, ymax = upper__), colour = "red", alpha = 0.5)
```

```{r echo=TRUE, fig.height=6, fig.width=6, message=FALSE}
# Deriving coeffs in three different ways
ce <- conditional_effects(x = fit2, effects = "Area", method = "pp_expect")

newdata <- data.frame(id = 1:3, Year = NA, Species = NA, Area = unique(fit2$data$Area))
pp <- pp_expect(fit2, newdata = newdata) %>%
  melt(varnames = c("iteration", "id")) %>%
  left_join(newdata, by = "id")
# pp$value <- pp$value - mean(pp$value)
# cc <- get_coefs(fit2, var = "Area") %>%
#   mutate(Area = extract_numeric(variable))
# cc$value <- cc$value - mean(cc$value)

psi <- posterior_samples(fit2, pars = "Intercept") %>%
  mutate(iteration = 1:n()) %>%
  melt(id.vars = "iteration") %>%
  mutate(variable = gsub("b_", "", .data$variable)) 
psa <- posterior_samples(fit2, pars = "Area") %>%
  mutate(iteration = 1:n()) %>%
  melt(id.vars = "iteration") %>%
  mutate(variable = gsub("b_", "", .data$variable)) %>%
  mutate(Area = parse_number(variable)) %>%
  left_join(psi, by = "iteration") %>%
  mutate(value = exp(value.x + value.y)) %>%
  select(iteration, Area, value)
psi2 <- psi %>%
  mutate(Area = 0, value = exp(value)) %>%
  select(iteration, Area, value)
ps <- rbind(psi2, psa)

p <- ggplot(data = pp) +
  geom_violin(aes(x = Area, y = value), draw_quantiles = c(0.025, 0.975)) +
  geom_pointrange(data = ce[[1]], aes(x = Area, y = estimate__, ymin = lower__, ymax = upper__), colour = "red", alpha = 0.5) +
  # geom_violin(data = cc, aes(x = factor(Area), y = value), fill = "green", alpha = 0.5)
  geom_violin(data = ps, aes(x = factor(Area), y = value), fill = "green", alpha = 0.5)
p
```
